test1 <- function(otudata, metadata=NA, taxonomydata=NA,
                     thresh_prevalence=80, thresh_abundance=0.5, thresh_abundance_override=NA, thresh_NA=5,
                     regularInterval=NA, maxGap=NA,
                     otulist=NA,
                     subj=NA,
                     band.thickness=NA, origin=NA,
                     facetLabelsByTaxonomy=FALSE, customFacetLabels=NA,
                     interpolate_NA=TRUE, formatStep=FALSE, col.outline="#CCCCCC",
                     col.brew=c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
{
  # Check and fix otudata format
  if(FALSE %in% (sapply(otudata,class)[-1] == "integer")) {
    stop("All columns of otudata except the first must be of class integer")
  }
  colnames(otudata)[1] <- "otuid"

  # Convert data to %
  otudata[,-1] <- apply(otudata[,-1],2,function(x){100*x/sum(as.numeric(x),na.rm=TRUE)})

  # Check filtering thresholds
  if(is.na(thresh_prevalence) | class(thresh_prevalence) != "numeric") {
    stop("thresh_prevalence must be of type numeric")
  }
  if(thresh_prevalence > 100 | thresh_prevalence < 0) {
    stop("thresh_prevalence must be a number between 0 and 100")
  }
  if(thresh_prevalence < 1 & thresh_prevalence > 0) {
    warning(paste("thresh_prevalence is less than 1%, and is supposed to be a number between 0 and 100. Did you mean thresh_prevalence=",100*thresh_prevalence,"?",sep=""))
  }
  if(is.na(thresh_abundance) | class(thresh_abundance) != "numeric") {
    stop("thresh_abundance must be of type numeric")
  }
  if(thresh_abundance > 100 | thresh_abundance < 0) {
    stop("thresh_abundance must be a number between 0 and 100")
  }
  if(!is.na(thresh_abundance_override)) {
    if(class(thresh_abundance_override) != "numeric") {
      stop("thresh_abundance_override must be of type numeric")
    }
    if(thresh_abundance_override<0 | thresh_abundance_override>100) {
      stop("thresh_abundance_override must be a number between 0 and 100 (or NA)")
    }
  }
  if(is.na(thresh_NA) | class(thresh_NA) != "numeric") {
    stop("thresh_NA must be of type numeric")
  }
  if(thresh_NA > 100 | thresh_NA < 0) {
    stop("thresh_NA must be a number between 0 and 100")
  }

  # Filter otudata
  if(is.na(otulist)) {
    otudata$nonzero <- rowSums(otudata[,-1] != 0, na.rm = TRUE)
    otudata$prevalence <- 100 * otudata$nonzero/(ncol(otudata)-2)
    otudata$abundance <- rowSums(otudata[,2:(ncol(otudata)-2)], na.rm=TRUE) / otudata$nonzero
    otudata$nacount <- rowSums(is.na(otudata[,2:(ncol(otudata)-3)]))
    otudata <- dplyr::filter(otudata, (100 * nacount / (ncol(otudata)-5) < thresh_NA) & ((prevalence > thresh_prevalence & abundance > thresh_abundance) | (!is.na(thresh_abundance_override) & abundance > thresh_abundance_override))) %>%
      dplyr::select(-nonzero, -prevalence, -abundance, -nacount)
  } else {
    otudata <- otudata %>% dplyr::filter(otuid %in% otulist)
    if(nrow(otudata)==0) {
      stop("no values in otulist match otuids in otudata; all rows filtered out")
    }
  }

  # Filter metadata and otudata samples by subject
  if(!is.na(subj)) {
    if(!is.data.frame(metadata)) {
      stop("cannot filter otudata by subject without metadata on sample and subject")
    }
    if(!("subject" %in% colnames(metadata))) {
      stop("metadata must contain variable \"subject\" to filter by subject")
    }
    metadata <- metadata %>% dplyr::filter(subject==subj)
    if(!("sample" %in% colnames(metadata))) {
      stop("metadata must contain variable sample")
    }
    otudata[,-1] <- otudata[,-1][,colnames(otudata) %in% metadata$sample]
  }

  # Determine timestamps, if metadata provided; select and order otudata samples
  if(is.data.frame(metadata)) {
    if("collection_date" %in% colnames(metadata)) {
      if(class(metadata$collection_date)=="Date") {
        if(!("sample" %in% colnames(metadata))) {
          stop("metadata must contain variable sample")
        }
        if(nrow(metadata) != (ncol(otudata)-1)) {
          warning("Number of sample rows in metadata does not match number of sample columns in otudata. Sample columns not in metadata have been removed.")
        }
        if(NA %in% metadata$collection_date) {
          stop("NAs found in metadata$collection_date")
        }

        metadata <- metadata %>%
          dplyr::mutate(collection_date=as.numeric(collection_date)) %>%
          dplyr::arrange(collection_date)
        if(sum(metadata$sample %in% colnames(otudata)) < (ncol(otudata)-1)) {
          colnames(otudata)[-1] <- as.character(metadata$sample)
          warning("Some columns in otudata have no match in metadata. Assigning sample names based on collection_date.")
        }

        tempdf <- otudata[,-1]
        tempdf <- tempdf %>% dplyr::select(which(colnames(tempdf) %in% as.character(metadata$sample)))
        otudata <- cbind(otuid=otudata$otuid,tempdf)

        timestamps <- 1 + metadata$collection_date - metadata$collection_date[1]
      } else {
        stop("variable collection_date in metadata must be of class Date")
      }
    } else {
      stop("metadata must contain variable collection_date")
    }
  } else {
    timestamps <- NA
  }

  # Check taxonomydata format
  if(is.data.frame(taxonomydata)) {
    if(ncol(taxonomydata) > 8) {
      stop("taxonomydata has more than 8 columns; the function does not support classification past Species")
    }
    taxonomynames <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
    colnames(taxonomydata) <- c("otuid",taxonomynames[1:(ncol(taxonomydata)-1)])
    taxonomydata <- taxonomydata %>% dplyr::filter(otuid %in% otudata$otuid)

    if(nrow(taxonomydata) != nrow(otudata)) {
      stop("number of OTU rows in taxonomydata does not match number of OTU rows in otudata")
    }
  } else {
    taxonomydata <- NA
  }

  # Set variables to correct values
  if(!is.na(regularInterval) & regularInterval<=0) {
    regularInterval <- NA
  }
  if(is.na(regularInterval)) {
    maxGap <- NA
  } else {
    if(!is.na(maxGap) & maxGap < regularInterval) {
      maxGap <- NA
      warning("maxGap is less than regularInterval; setting to default maxGap=NA")
    }
  }
  if(is.na(formatStep)) {
    formatStep <- FALSE
  } else {
    if(class(formatStep) != "logical") {
      stop("formatStep must be of type logical")
    }
  }
  if(is.na(interpolate_NA)) {
    interpolate_NA <- FALSE
  } else {
    if(class(interpolate_NA) != "logical") {
      stop("interpolate_NA must be of type logical")
    }
  }
  if(is.na(facetLabelsByTaxonomy)) {
    facetLabelsByTaxonomy <- FALSE
  } else {
    if(class(facetLabelsByTaxonomy) != "logical") {
      stop("facetLabelsByTaxonomy must be of type logical")
    }
  }
  if(!is.na(customFacetLabels) & length(customFacetLabels) != nrow(otudata)) {
    warning("customFacetLabels is not the same length as number of OTUs, using default labels.")
    customFacetLabels <- NA
  }
  if(is.na(col.outline)) {
    col.outline <- "#CCCCCC"
  } else {
    if(class(col.outline) != "character") {
      stop("col.outline must be a hexadecimal color of type character")
    } else {
      if(nchar(col.outline) != 7) {
        stop("col.outline must be in hexadecimal color format (e.g. #CCCCCC)")
      }
    }
  }
  # Colorset for bands (default 3 bands)
  if(NA %in% col.brew) {
    col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
  } else {
    if(class(col.brew) != "character") {
      warning("col.brew must be a hexadecimal color vector of type character. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
    if(length(col.brew) < 6) {
      warning("col.brew has <6 color values, not enough for at least 3 bands. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
    if(length(col.brew) %% 2 != 0) {
      warning("col.brew has an odd number of color values. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
  }
  nbands <- length(col.brew) / 2

  # Set functions
  if(is.na(origin)) {
    origin <- function(y) {
      median(y, na.rm=TRUE)
    }
  } else {
    if(is.numeric(origin)) {
      originconstant <- origin
      origin <- function(y) { originconstant }
    } else {
      if(!is.function(origin)) {
        warning("origin must be a function operating on a numeric vector. Using default function (median).")
        origin <- function(y) {
          median(y, na.rm=TRUE)
        }
      }
    }
  }

  if(is.na(band.thickness)) {
    band.thickness <- function(y) {
      max((abs(y - origin(y))), na.rm=TRUE) / nbands
    }
  } else {
    if(is.numeric(band.thickness)) {
      bandthicknessconstant <- band.thickness
      band.thickness <- function(y) { bandthicknessconstant }
    } else {
      if(!is.function(band.thickness)) {
        warning("band.thickness must be a function operating on a numeric vector. Using default function.")
        band.thickness <- function(y) {
          max((abs(y - origin(y))), na.rm=TRUE) / nbands
        }
      }
    }
  }

  fill_NA <- ifelse(interpolate_NA, function(y){zoo::na.approx(y)}, function(y){zoo::na.fill(y,0)})

  cat("Constructed an OTU table and other variables with the following settings:",
      paste("thresh_prevalence:", thresh_prevalence),
      paste("thresh_abundance:", thresh_abundance),
      paste("thresh_abundance_override:", thresh_abundance_override),
      paste("thresh_NA:", thresh_NA),
      paste("subj:", subj),
      sep="\n")

  list(otudata,taxonomydata,timestamps,otulist,
       regularInterval,maxGap,band.thickness,origin,
       facetLabelsByTaxonomy,customFacetLabels,
       fill_NA,nbands,formatStep,col.brew,col.outline)
}


test2 <- function(parameterList) {
  if(length(parameterList) != 15) {
    stop("parameterList must be of length 15; use output list from prepanel function")
  }

  otudata <- parameterList[[1]]
  taxonomydata <- parameterList[[2]]
  timestamps <- parameterList[[3]]
  otulist <- parameterList[[4]]
  regularInterval <- parameterList[[5]]
  maxGap <- parameterList[[6]]
  band.thickness <- parameterList[[7]]
  origin <- parameterList[[8]]
  facetLabelsByTaxonomy <- parameterList[[9]]
  customFacetLabels <- parameterList[[10]]
  fill_NA <- parameterList[[11]]
  nbands <- parameterList[[12]]
  formatStep <- parameterList[[13]]
  col.brew <- parameterList[[14]]
  col.outline <- parameterList[[15]]

  # Origin-center, save band-thicknesses into new column.
  otudata$bt <- numeric(nrow(otudata))
  for(i in 1:nrow(otudata)) {
    otudata[i,2:(ncol(otudata)-1)] <- as.numeric(otudata[i,2:(ncol(otudata)-1)]) - origin(as.numeric(otudata[i,2:(ncol(otudata)-1)]))
    otudata$bt[i] <- band.thickness(as.numeric(otudata[i,2:(ncol(otudata)-1)]))
  }

  # Change sample IDs to corresponding dates and melt data
  if(!is.na(regularInterval)) {
    newTimestamps <- seq(from=1, to=max(timestamps), by=regularInterval)
    indPrev <- numeric()
    for(i in 1:length(newTimestamps)) {
      indPrev[i] <- max(which(timestamps <= newTimestamps[i]))
    }

    templist <- list()
    for(i in 1:length(newTimestamps)) {
      y1 <- otudata[,1+indPrev[i]]
      y2 <- otudata[,2+indPrev[i]]
      t1 <- timestamps[indPrev[i]]
      t2 <- timestamps[indPrev[i]+1]
      Ti <- newTimestamps[i]

      templist[[i]] <- pmin(y1,y2) + (Ti-t1)*(abs(y2-y1)/(t2-t1))

      if(!is.na(maxGap) & !(Ti==t1 | Ti==t2) & (abs(Ti-t1) > maxGap | abs(Ti-t2) > maxGap)) {
        templist[[i]] <- NA
      }
    }
    newdata <- as.data.frame(templist)
    rm(templist)
    colnames(newdata) <- newTimestamps
    otudata <- cbind(otuid=otudata$otuid,newdata,bt=otudata$bt)
  } else {
    colnames(otudata)[2:(ncol(otudata)-1)] <- as.character(1:(ncol(otudata)-2))
  }

  # Fill NAs using selected method
  if(is.na(regularInterval) | is.na(maxGap)) {
    otudata[,2:(ncol(otudata)-1)] <- as.data.frame(t(fill_NA(t(otudata[,2:(ncol(otudata)-1)]))))
  } else {
    nums <- otudata %>% dplyr::select(-otuid, -bt)
    breakpts <- as.numeric(c(-1*regularInterval,colnames(nums)[colSums(is.na(nums))==nrow(nums)],regularInterval+as.numeric(colnames(nums)[ncol(nums)])))
    naCols <- as.character(breakpts[c(-1,-length(breakpts))])
    otudata <- otudata %>% dplyr::select(-naCols)
    rm(naCols)
  }

  # formatStep = FALSE: add extra points for interpolation
  extrapts <- data.frame(character(),numeric(),numeric(),numeric())
  colnames(extrapts) <- c("otuid","bt","day","value")
  dX <- ifelse(is.na(regularInterval), 1, regularInterval)

  if(!formatStep) {
    for(r in 1:nrow(otudata)) {
      bt <- otudata[r,ncol(otudata)]
      nums <- otudata[r,c(-1,-ncol(otudata))]

      bands <- 1 # Every point is at least a member of the lowest band
      for(n in (-1*nbands+1):(nbands-1)) {
        bands <- bands + (nums > n*bt)
      }
      bands <- bands-nbands

      x <- numeric()
      y <- numeric()

      for(i in 1:(2*nbands-1)) {
        # UPCROSSINGS
        upcrossings <- as.numeric(which(bands-dplyr::lead(bands) == -i)) # The indices where the sample is about to increase band
        if(length(upcrossings>0)) {
          y1 <- as.numeric(nums[upcrossings]) # Note that this is a dataframe without conversion...
          y2 <- as.numeric(nums[upcrossings+1])
          for(j in 0:(i-1)) {
            # Add a point.
            newY <- bt*(bands[upcrossings]+j)
            newX <- as.numeric(names(nums)[upcrossings]) + ((newY-y1)/(y2-y1)) * dX

            x <- c(x,newX)
            y <- c(y,newY)
          }
        }

        # DOWNCROSSINGS
        downcrossings <- as.numeric(which(bands-dplyr::lead(bands) == i)) # The indices where the sample is about to decrease band
        if(length(downcrossings>0)) {
          y1 <- as.numeric(nums[downcrossings])
          y2 <- as.numeric(nums[downcrossings+1])
          for(j in 0:(i-1)) {
            # Add a point.
            newY <- bt*(bands[downcrossings+1]+j)
            newX <- as.numeric(names(nums)[downcrossings])+dX - ((newY-y2)/(y1-y2)) * dX

            x <- c(x,newX)
            y <- c(y,newY)
          }
        }
      }

      if(length(x)>0) {
        extrapts <- rbind.data.frame(extrapts, data.frame(otuid=otudata[r,1],bt=bt,day=as.character(x),value=y, stringsAsFactors=FALSE))
      }
    }
  }

  # Melt data into a date column
  otudata <- otudata %>% tidyr::gather(key=day,value=value,-c("otuid","bt"))
  otudata$otuid <- as.character(otudata$otuid)
  otudata$day <- as.character(otudata$day)

  otudata <- rbind.data.frame(otudata,extrapts) # Merge regular points and intermediate points

  # Add band columns
  for (i in 1:nbands) {
    #positive
    otudata[,paste("ypos",i,sep="")] <- ifelse(otudata$value > 0,
                                               ifelse(abs(otudata$value) > otudata$bt * i,
                                                      otudata$bt,
                                                      ifelse(abs(otudata$value) - (otudata$bt * (i - 1)) > 0, abs(otudata$value) - (otudata$bt * (i - 1)), 0)), 0)
    #negative
    otudata[,paste("yneg",i,sep="")] <- ifelse(otudata$value < 0,
                                               ifelse(abs(otudata$value) > otudata$bt * i,
                                                      otudata$bt,
                                                      ifelse(abs(otudata$value) - (otudata$bt * (i - 1)) > 0, abs(otudata$value) - (otudata$bt * (i - 1)), 0)), 0)
  }

  # Melt data and graph it
  otudata <- otudata[,c(1,3,5:ncol(otudata))] %>% tidyr::gather(key=band,value=value,-(1:2))

  colorcodes <- numeric(nbands*2)
  for(i in 1:nbands) {
    colorcodes[i] <- paste("yneg",nbands-i+1,sep="")
  }
  for(i in (nbands+1):(nbands*2)) {
    colorcodes[i] <- paste("ypos",i-nbands,sep="")
  }
  names(col.brew) <- colorcodes

  if(formatStep) {
    # Add additional steps to dataframe
    otudata <- otudata %>% dplyr::arrange(otuid)
    otudata_extraSteps <- otudata %>% dplyr::mutate(value = ifelse(day==1,NA,dplyr::lag(value)))
    otudata <- bind_rows(old = otudata, new = otudata_extraSteps, .id = "source") %>%
      dplyr::arrange(otuid, band, day, source)
  }

  if(!is.na(maxGap) && length(breakpts)!=0) {
    otudata <- addFacets(otudata,breakpts,regularInterval)
  }

  # Arrange OTU rows according to order of otuid
  if(!is.na(otulist)) {
    otudata <- otudata %>% dplyr::arrange(as.numeric(day),band,factor(otuid,levels=otulist))
  }

  if(!is.na(customFacetLabels)) {
    facetLabels <- customFacetLabels
  } else {

    if(facetLabelsByTaxonomy & is.data.frame(taxonomydata)) {
      facetLabels <- taxonomydata %>%
        dplyr::arrange(otudata$otuid[1:nrow(taxonomydata)]) %>%
        apply(1,function(x){dplyr::last(x[!is.na(x)])})
    } else {
      facetLabels <- as.character(otudata$otuid)
    }

  }
  names(facetLabels) <- otudata$otuid[1:nrow(taxonomydata)]

  p <- ggplot(data=otudata) +
    geom_area(aes(x = as.numeric(day), y = value, fill=band), position="identity", color=col.outline) +  #this means not stacked
    scale_fill_manual(values=col.brew) +
    theme_bw() +
    theme(axis.text.x=element_text(size=16), axis.text.y=element_blank(), axis.ticks.y=element_blank(), panel.grid=element_blank(), panel.border=element_rect(color=col.outline), strip.text.y=element_text(angle=180), panel.spacing.y=unit(0, units="cm")) +
    guides(fill=FALSE) +
    scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0)) + # remove margins between plot and panel
    xlab(element_blank()) + ylab(element_blank())

  if(!is.na(maxGap) && maxGap!=0 && length(breakpts)!=0) {
    p <- p + facet_grid(otuid ~ type, scales="free", labeller=labeller(otuid=facetLabels), switch="y") #do new subplot for each otu
  } else {
    p <- p + facet_grid(otuid ~ ., scales="free", labeller=labeller(otuid=facetLabels), switch="y") #do new subplot for each otu
  }
  breakpts <- numeric()

  cat("Constructed a horizon plot with the following settings:",
      paste("regularInterval:", regularInterval),
      paste("maxGap:", maxGap),
      paste("facetLabelsByTaxonomy:", facetLabelsByTaxonomy),
      paste("formatStep:", formatStep),
      paste("nbands:", nbands),
      paste("origin:", deparse(origin)),
      paste("band.thickness:", deparse(band.thickness)),
      paste("fill_NA:", deparse(fill_NA)),
      sep="\n")

  p
}
