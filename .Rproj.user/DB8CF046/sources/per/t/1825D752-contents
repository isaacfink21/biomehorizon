# CHANGE part where facetLabelsByTaxonomy=FALSE that requires taxonomydata$otuid!!!!!!


# NOTES
# How to include brief periods of abundance? (Just for ones very abundant? So if it meets a certain abundance threshold then keep it no matter what?) --> another argument for "no matter what" abundance; if NA don't use (so check for !is.na() before checking if over the value)
# Check for variable as CHANGE?
# Up or down-regulate based on a desired amount of OTUs, or a range (if below 30 to 30, if above 40 to 40)
# Automatic regulation? (Put in no. OTUs as an argument)

# VERY IMPORTANT: ENSURE THAT YOU DO NOT MAKE THE CODING ERROR
#         otudata[8:ncol(otudata)-1]
# THIS WILL SUBTRACT ONE FROM THE ENTIRE SEQUENCE 8:ncol MAKING IT 7:(ncol-1)
# IF YOU USE as.numeric(), THIS WILL CONVERT A CHARACTER TO A (very large) NUMBER!!!
# Additionally, if you use as.numeric(), this will convert a dataframe to a vector!!

library(dplyr)
library(reshape2) #tidyr spread, gather
library(tidyr)
library(ggplot2)
library(RColorBrewer) # can remove
library(zoo)

otupath <- "C:/Users/19IsaacAF/Downloads/horizon_otu_table1.csv"
metadatapath <- "C:/Users/19IsaacAF/Downloads/horizon_metadata1.csv"

# Desired subject to analyze
subject <- "LEB"
# Data files
otudata <- read.table(otupath, header=TRUE, sep=",")
metadata <- read.table(metadatapath, header=TRUE, sep=",")
# % Prevalence and abundance thresholds for OTU selection
thresh_prevalence <- 80
thresh_abundance <- 0.5
thresh_abundance_override <- NA
thresh_NA <- 5
# thresh change? (abs max - min)
# Manual OTU selection
# Will plot OTU rows in the specified order. Note: if you want to plot OTUs in a specific order of rows, assign that order to otulist!
otulist <- testb
# Origin and band thickness (these are defaults, otherwise supply a function)
band.thickness <- NA # default max/3; MAD used in a paper but didn't seem to work well here (values near the top significantly above bt)
origin <- NA
# Colorset for bands (default 4 bands)
col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
#col.brew <- c("#1240AB","#009999", "#00CC00", "#9FEE00", "#FFD300", "#FFAA00", "#FF7400", "#FF0000")
# Color for outline (NA for no outline)
col.outline <- "#CCCCCC"
# Facet labels -- if TRUE, by taxonomy; if FALSE (or NA), by otuid
facetLabelsByTaxonomy <- FALSE
# Custom vector for facet labels (default=NA: disregard)
customFacetLabels <- NA
# Interpolate NAs. If set to FALSE, all NA sample values will be set to 0.
interpolate_NA <- TRUE
# Format as a step-graph. If FALSE, format is line graph that interpolates
formatStep <- FALSE

regularInterval <- 50 # Must be an integer. default = NA. NA or 0 means no regularization.
maxGap <- 300 # Defaults to regularInterval. NA or 0 = no maxGap (interpolate for all pts)
# ^ should be NA if regularInterval is NA

# PREFORMATTING FUNCTION to ensure data format is valid, all variable entries are valid? (e.g. booleans are not NA, color vector is in right format, etc. else set to their defaults.  Like prepanel)
# The purpose of this function is to catch errors and prompt the user before they cause issues later.
# Going on, assume all variables are in correct format.

# Include only samples belonging to the subject; order by date
metadata <- filter(metadata, sname == subject)
ind <- order(as.Date(metadata$collection_date))
metadata <- data.frame(sample=as.character(metadata$sample[ind]),sname=as.character(metadata$sname[ind]), collection_date=as.Date(metadata$collection_date[ind]), stringsAsFactors=FALSE)
otudata <- otudata[otudata$Kingdom != "Eukaryota", colnames(otudata) %in% c(metadata$sample, "otuid", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus")]

taxonomydata <- otudata[,1:7] # Optional (Default=NA)
otudata <- otudata[,-(2:7)]

# Integer vector corresponding to days of sample collection for irregular time series.
# Default=NA (do not balance scale)
# First number should always be 1.
# Set to either NA or of same length as ncol
timestamps <- as.numeric(metadata$collection_date) - 11148 # IF BY VECTOR, optional


prepanel <- function(otudata, metadata=NA, taxonomydata=NA,
                     thresh_prevalence=80, thresh_abundance=0.5, thresh_abundance_override=NA, thresh_NA=5,
                     regularInterval=NA, maxGap=NA,
                     otulist=NA,
                     subj=NA,
                     band.thickness=NA, origin=NA,
                     facetLabelsByTaxonomy=FALSE, customFacetLabels=NA,
                     interpolate_NA=TRUE, formatStep=FALSE, col.outline="#CCCCCC",
                     col.brew=c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
{
  # Check and fix otudata format
  if(FALSE %in% (sapply(otudata,class)[-1] == "integer")) {
    stop("All columns of otudata except the first must be of class integer")
  }
  colnames(otudata)[1] <- "otuid"

  # Convert data to %
  otudata[,-1] <- apply(otudata[,-1],2,function(x){100*x/sum(as.numeric(x),na.rm=TRUE)})

  # Check filtering thresholds
  if(is.na(thresh_prevalence) | class(thresh_prevalence) != "numeric") {
    stop("thresh_prevalence must be of type numeric")
  }
  if(thresh_prevalence > 100 | thresh_prevalence < 0) {
    stop("thresh_prevalence must be a number between 0 and 100")
  }
  if(thresh_prevalence < 1 & thresh_prevalence > 0) {
    warning(paste("thresh_prevalence is less than 1%, and is supposed to be a number between 0 and 100. Did you mean thresh_prevalence=",100*thresh_prevalence,"?",sep=""))
  }
  if(is.na(thresh_abundance) | class(thresh_abundance) != "numeric") {
    stop("thresh_abundance must be of type numeric")
  }
  if(thresh_abundance > 100 | thresh_abundance < 0) {
    stop("thresh_abundance must be a number between 0 and 100")
  }
  if(!is.na(thresh_abundance_override)) {
    if(class(thresh_abundance_override) != "numeric") {
      stop("thresh_abundance_override must be of type numeric")
    }
    if(thresh_abundance_override<0 | thresh_abundance_override>100) {
      stop("thresh_abundance_override must be a number between 0 and 100 (or NA)")
    }
  }
  if(is.na(thresh_NA) | class(thresh_NA) != "numeric") {
    stop("thresh_NA must be of type numeric")
  }
  if(thresh_NA > 100 | thresh_NA < 0) {
    stop("thresh_NA must be a number between 0 and 100")
  }

  # Filter otudata
  if(is.na(otulist)) {
    otudata$nonzero <- rowSums(otudata[,-1] != 0, na.rm = TRUE)
    otudata$prevalence <- 100 * otudata$nonzero/(ncol(otudata)-2)
    otudata$abundance <- rowSums(otudata[,2:(ncol(otudata)-2)], na.rm=TRUE) / otudata$nonzero
    otudata$nacount <- rowSums(is.na(otudata[,2:(ncol(otudata)-3)]))
    otudata <- filter(otudata, (100 * nacount / (ncol(otudata)-5) < thresh_NA) & ((prevalence > thresh_prevalence & abundance > thresh_abundance) | (!is.na(thresh_abundance_override) & abundance > thresh_abundance_override))) %>%
      select(-nonzero, -prevalence, -abundance, -nacount)
  } else {
    otudata <- otudata %>% filter(otuid %in% otulist)
    if(nrow(otudata)==0) {
      stop("no values in otulist match otuids in otudata; all rows filtered out")
    }
  }

  # Filter metadata by subject
  if(!is.na(subj)) {
    if(!is.data.frame(metadata)) {
      stop("cannot filter otudata by subject without metadata on sample and subject")
    }
    if(!("subject" %in% colnames(metadata))) {
      stop("metadata must contain variable subj to filter by subject")
    }
    metadata <- metadata %>% filter(subject==subj)
  }

  # Determine timestamps, if metadata provided; select and order otudata samples
  if(is.data.frame(metadata)) {
    if("collection_date" %in% colnames(metadata)) {
      if(class(metadata$collection_date)=="Date") {
        if(!("sample" %in% colnames(metadata))) {
          stop("metadata must contain variable sample")
        }
        if(nrow(metadata) != (ncol(otudata)-1)) {
          warning("Number of sample rows in metadata does not match number of sample columns in otudata. Sample columns not in metadata have been removed.")
        }
        if(NA %in% metadata$collection_date) {
          stop("NAs found in metadata$collection_date")
        }

        metadata <- metadata %>%
          mutate(collection_date=as.numeric(collection_date)) %>%
          arrange(collection_date)
        if(sum(metadata$sample %in% colnames(otudata)) < (ncol(otudata)-1)) {
          colnames(otudata)[-1] <- as.character(metadata$sample)
          warning("Some columns in otudata have no match in metadata. Assigning sample names based on collection_date.")
        }

        tempdf <- otudata[,-1]
        tempdf <- tempdf %>% select(which(colnames(tempdf) %in% as.character(metadata$sample)))
        otudata <- cbind(otuid=otudata$otuid,tempdf)

        timestamps <- 1 + metadata$collection_date - metadata$collection_date[1]
      } else {
        stop("variable collection_date in metadata must be of class Date")
      }
    } else {
      stop("metadata must contain variable collection_date")
    }
  } else {
    timestamps <- NA
  }

  # Check taxonomydata format
  if(is.data.frame(taxonomydata)) {
    if(ncol(taxonomydata) > 8) {
      stop("taxonomydata has more than 8 columns; the function does not support classification past Species")
    }
    taxonomynames <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
    colnames(taxonomydata) <- c("otuid",taxonomynames[1:(ncol(taxonomydata)-1)])
    taxonomydata <- taxonomydata %>% filter(otuid %in% otudata$otuid)

    if(nrow(taxonomydata) != nrow(otudata)) {
      stop("number of OTU rows in taxonomydata does not match number of OTU rows in otudata")
    }
  } else {
    taxonomydata <- NA
  }

  # Set variables to correct values
  if(!is.na(regularInterval) & regularInterval<=0) {
    regularInterval <- NA
  }
  if(is.na(regularInterval)) {
    maxGap <- NA
  } else {
    if(!is.na(maxGap) & maxGap < regularInterval) {
      maxGap <- NA
      warning("maxGap is less than regularInterval; setting to default maxGap=NA")
    }
  }
  if(is.na(formatStep)) {
    formatStep <- FALSE
  } else {
    if(class(formatStep) != "logical") {
      stop("formatStep must be of type logical")
    }
  }
  if(is.na(interpolate_NA)) {
    interpolate_NA <- FALSE
  } else {
    if(class(interpolate_NA) != "logical") {
      stop("interpolate_NA must be of type logical")
    }
  }
  if(is.na(facetLabelsByTaxonomy)) {
    facetLabelsByTaxonomy <- FALSE
  } else {
    if(class(facetLabelsByTaxonomy) != "logical") {
      stop("facetLabelsByTaxonomy must be of type logical")
    }
  }
  if(!is.na(customFacetLabels) & length(customFacetLabels) != nrow(otudata)) {
    warning("customFacetLabels is not the same length as number of OTUs, using default labels.")
    customFacetLabels <- NA
  }
  if(is.na(col.outline)) {
    col.outline <- "#CCCCCC"
  } else {
    if(class(col.outline) != "character") {
      stop("col.outline must be a hexadecimal color of type character")
    } else {
      if(nchar(col.outline) != 7) {
        stop("col.outline must be in hexadecimal color format (e.g. #CCCCCC)")
      }
    }
  }
  # Colorset for bands (default 3 bands)
  if(NA %in% col.brew) {
    col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
  } else {
    if(class(col.brew) != "character") {
      warning("col.brew must be a hexadecimal color vector of type character. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
    if(length(col.brew) < 6) {
      warning("col.brew has <6 color values, not enough for at least 3 bands. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
    if(length(col.brew) %% 2 != 0) {
      warning("col.brew has an odd number of color values. Using default colorset.")
      col.brew <- c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#92C5DE", "#4393C3", "#2166AC", "#053061")
    }
  }
  nbands <- length(col.brew) / 2

  # Set functions
  if(is.na(origin)) {
    origin <- function(y) {
      median(y, na.rm=TRUE)
    }
  } else {
    if(is.numeric(origin)) {
      originconstant <- origin
      origin <- function(y) { originconstant }
    } else {
      if(!is.function(origin)) {
        warning("origin must be a function operating on a numeric vector. Using default function (median).")
        origin <- function(y) {
          median(y, na.rm=TRUE)
        }
      }
    }
  }

  if(is.na(band.thickness)) {
    band.thickness <- function(y) {
      max((abs(y - origin(y))), na.rm=TRUE) / nbands
    }
  } else {
    if(is.numeric(band.thickness)) {
      bandthicknessconstant <- band.thickness
      band.thickness <- function(y) { bandthicknessconstant }
    } else {
      if(!is.function(band.thickness)) {
        warning("band.thickness must be a function operating on a numeric vector. Using default function.")
        band.thickness <- function(y) {
          max((abs(y - origin(y))), na.rm=TRUE) / nbands
        }
      }
    }
  }

  fill_NA <- ifelse(interpolate_NA, function(y){na.approx(y)}, function(y){na.fill(y,0)})

  cat("Constructed an OTU table and other variables with the following settings:",
      paste("thresh_prevalence:", thresh_prevalence),
      paste("thresh_abundance:", thresh_abundance),
      paste("thresh_abundance_override:", thresh_abundance_override),
      paste("thresh_NA:", thresh_NA),
      paste("subj:", subj),
      sep="\n")

  list(otudata,taxonomydata,timestamps,otulist,
       regularInterval,maxGap,band.thickness,origin,
       facetLabelsByTaxonomy,customFacetLabels,
       fill_NA,nbands,
       interpolate_NA,formatStep,col.brew,col.outline)
}

horizonplot <- function(parameterList) {
  if(length(parameterList) != 16) {
    stop("parameterList must be of length 16; use output list from prepanel function")
  }

  otudata <- parameterList[[1]]
  taxonomydata <- parameterList[[2]]
  timestamps <- parameterList[[3]]
  otulist <- parameterList[[4]]
  regularInterval <- parameterList[[5]]
  maxGap <- parameterList[[6]]
  band.thickness <- parameterList[[7]]
  origin <- parameterList[[8]]
  facetLabelsByTaxonomy <- parameterList[[9]]
  customFacetLabels <- parameterList[[10]]
  fill_NA <- parameterList[[11]]
  nbands <- parameterList[[12]]
  interpolate_NA <- parameterList[[13]]
  formatStep <- parameterList[[14]]
  col.brew <- parameterList[[15]]
  col.outline <- parameterList[[16]]

  # Origin-center, save band-thicknesses into new column.
  otudata$bt <- numeric(nrow(otudata))
  for(i in 1:nrow(otudata)) {
    otudata[i,2:(ncol(otudata)-1)] <- as.numeric(otudata[i,2:(ncol(otudata)-1)]) - origin(as.numeric(otudata[i,2:(ncol(otudata)-1)]))
    otudata$bt[i] <- band.thickness(as.numeric(otudata[i,2:(ncol(otudata)-1)]))
  }

  # Change sample IDs to corresponding dates and melt data
  if(!is.na(regularInterval)) {
    newTimestamps <- seq(from=1, to=max(timestamps), by=regularInterval)
    indPrev <- numeric()
    for(i in 1:length(newTimestamps)) {
      indPrev[i] <- max(which(timestamps <= newTimestamps[i]))
    }

    templist <- list()
    for(i in 1:length(newTimestamps)) {
      y1 <- otudata[,1+indPrev[i]]
      y2 <- otudata[,2+indPrev[i]]
      t1 <- timestamps[indPrev[i]]
      t2 <- timestamps[indPrev[i]+1]
      Ti <- newTimestamps[i]

      templist[[i]] <- pmin(y1,y2) + (Ti-t1)*(abs(y2-y1)/(t2-t1))

      if(!is.na(maxGap) & !(Ti==t1 | Ti==t2) & (abs(Ti-t1) > maxGap | abs(Ti-t2) > maxGap)) {
        templist[[i]] <- NA
      }
    }
    newdata <- as.data.frame(templist)
    rm(templist)
    colnames(newdata) <- newTimestamps
    otudata <- cbind(otuid=otudata$otuid,newdata,bt=otudata$bt)

    # If last index has a point, might get index error
  } else {
    colnames(otudata)[2:(ncol(otudata)-1)] <- as.character(1:(ncol(otudata)-2))
  }

  # Fill NAs using selected method
  if(is.na(regularInterval) | is.na(maxGap)) {
    otudata[,2:(ncol(otudata)-1)] <- as.data.frame(t(fill_NA(t(otudata[,2:(ncol(otudata)-1)]))))
  } else {
    # Do a graph break for irregular data gaps (columns of NA)
    # NO EASY WAY TO DO THIS -- DO FACET BREAKS JUST TO SHOW

    nums <- otudata %>% select(-otuid, -bt)
    breakpts <- as.numeric(c(-1*regularInterval,colnames(nums)[colSums(is.na(nums))==nrow(nums)],regularInterval+as.numeric(colnames(nums)[ncol(nums)])))
    naCols <- as.character(breakpts[c(-1,-length(breakpts))])
    otudata <- otudata %>% select(-naCols)
    rm(naCols)
  }

  # formatStep = FALSE: add extra points for interpolation
  extrapts <- data.frame(character(),numeric(),numeric(),numeric())
  colnames(extrapts) <- c("otuid","bt","day","value")
  dX <- ifelse(is.na(regularInterval), 1, regularInterval)

  if(!formatStep) {
    for(r in 1:nrow(otudata)) {
      bt <- otudata[r,ncol(otudata)]
      nums <- otudata[r,c(-1,-ncol(otudata))]

      bands <- 1 # Every point is at least a member of the lowest band
      for(n in (-1*nbands+1):(nbands-1)) {
        bands <- bands + (nums > n*bt)
      }
      bands <- bands-nbands

      x <- numeric()
      y <- numeric()

      for(i in 1:(2*nbands-1)) {
        # UPCROSSINGS
        upcrossings <- as.numeric(which(bands-lead(bands) == -i)) # The indices where the sample is about to increase band
        if(length(upcrossings>0)) {
          y1 <- as.numeric(nums[upcrossings]) # Note that this is a dataframe without conversion...
          y2 <- as.numeric(nums[upcrossings+1])
          for(j in 0:(i-1)) {
            # Add a point.
            newY <- bt*(bands[upcrossings]+j)
            newX <- as.numeric(names(nums)[upcrossings]) + ((newY-y1)/(y2-y1)) * dX

            x <- c(x,newX)
            y <- c(y,newY)
          }
        }

        # DOWNCROSSINGS
        downcrossings <- as.numeric(which(bands-lead(bands) == i)) # The indices where the sample is about to decrease band
        if(length(downcrossings>0)) {
          y1 <- as.numeric(nums[downcrossings])
          y2 <- as.numeric(nums[downcrossings+1])
          for(j in 0:(i-1)) {
            # Add a point.
            newY <- bt*(bands[downcrossings+1]+j)
            newX <- as.numeric(names(nums)[downcrossings])+dX - ((newY-y2)/(y1-y2)) * dX

            x <- c(x,newX)
            y <- c(y,newY)
          }
        }
      }

      if(length(x)>0) {
        extrapts <- rbind.data.frame(extrapts, data.frame(otuid=otudata[r,1],bt=bt,day=as.character(x),value=y, stringsAsFactors=FALSE))
      }
    }
  }

  # Melt data into a date column
  otudata <- otudata %>% gather(key=day,value=value,-c("otuid","bt"))
  #otudata <- melt(otudata, id.vars=c("otuid", "bt"))
  #colnames(otudata)[c(3,4)] <- c("day", "value")
  otudata$otuid <- as.character(otudata$otuid)
  otudata$day <- as.character(otudata$day)

  otudata <- rbind.data.frame(otudata,extrapts) # Merge regular points and intermediate points

  # Add band columns
  for (i in 1:nbands) {
    #positive
    otudata[,paste("ypos",i,sep="")] <- ifelse(otudata$value > 0,
                                               ifelse(abs(otudata$value) > otudata$bt * i,
                                                      otudata$bt,
                                                      ifelse(abs(otudata$value) - (otudata$bt * (i - 1)) > 0, abs(otudata$value) - (otudata$bt * (i - 1)), 0)), 0)
    #negative
    otudata[,paste("yneg",i,sep="")] <- ifelse(otudata$value < 0,
                                               ifelse(abs(otudata$value) > otudata$bt * i,
                                                      otudata$bt,
                                                      ifelse(abs(otudata$value) - (otudata$bt * (i - 1)) > 0, abs(otudata$value) - (otudata$bt * (i - 1)), 0)), 0)
  }

  # Melt data and graph it
  otudata <- otudata[,c(1,3,5:ncol(otudata))] %>% gather(key=band,value=value,-(1:2))
  #otudata <- melt(otudata[,c(1,3,5:ncol(otudata))], id.vars=1:2) # CHANGE CHANGE CHANGE
  #colnames(otudata)[3] <- "band"

  colorcodes <- numeric(nbands*2)
  for(i in 1:nbands) {
    colorcodes[i] <- paste("yneg",nbands-i+1,sep="")
  }
  for(i in (nbands+1):(nbands*2)) {
    colorcodes[i] <- paste("ypos",i-nbands,sep="")
  }
  names(col.brew) <- colorcodes

  if(formatStep) {
    # Add additional steps to dataframe
    otudata <- otudata %>% arrange(otuid)
    otudata_extraSteps <- otudata %>% mutate(value = ifelse(day==1,NA,lag(value)))
    otudata <- bind_rows(old = otudata, new = otudata_extraSteps, .id = "source") %>%
      arrange(otuid, band, day, source)
  }

  if(!is.na(maxGap) & length(breakpts)!=0) {
    otudata <- addFacets(otudata,breakpts,regularInterval)
  }

  # Arrange OTU rows according to order of otuid
  if(!is.na(otulist)) {
    otudata <- otudata %>% arrange(as.numeric(day),band,factor(otuid,levels=otulist))
  }

  if(!is.na(customFacetLabels)) {
    facetLabels <- customFacetLabels
  } else {

    if(facetLabelsByTaxonomy & is.data.frame(taxonomydata)) {
      facetLabels <- taxonomydata %>%
        arrange(otudata$otuid) %>%
        apply(1,function(x){last(x[!is.na(x)])})
    } else {
      facetLabels <- otudata$otuid
    }

  }
  names(facetLabels) <- otudata$otuid

  p <- ggplot(data=otudata) +
    geom_area(aes(x = as.numeric(day), y = value, fill=band), position="identity", color=col.outline) +  #this means not stacked
    scale_fill_manual(values=col.brew) +
    theme_bw() +
    theme(axis.text.x=element_text(size=16), axis.text.y=element_blank(), axis.ticks.y=element_blank(), panel.grid=element_blank(), panel.border=element_rect(color=col.outline), strip.text.y=element_text(angle=180), panel.spacing.y=unit(0, units="cm")) +
    guides(fill=FALSE) +
    scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0)) + # remove margins between plot and panel
    xlab(element_blank()) + ylab(element_blank())

  if(!is.na(maxGap) & maxGap!=0 & length(breakpts)!=0) {
    p <- p + facet_grid(otuid ~ type, scales="free", labeller=labeller(otuid=facetLabels), switch="y") #do new subplot for each otu
  } else {
    p <- p + facet_grid(otuid ~ ., scales="free", labeller=labeller(otuid=facetLabels), switch="y") #do new subplot for each otu
  }
  breakpts <- numeric()

  cat("Constructed a horizon plot with the following settings:",
      paste("regularInterval:", regularInterval),
      paste("maxGap:", maxGap),
      paste("facetLabelsByTaxonomy:", facetLabelsByTaxonomy),
      paste("formatStep:", formatStep),
      paste("interpolate_NA:", interpolate_NA),
      paste("nbands:", nbands),
      paste("origin:", deparse(origin)),
      paste("band.thickness:", deparse(band.thickness)),
      paste("fill_NA:", deparse(fill_NA)),
      sep="\n")

  p
}

addFacets <- function(x, boundaries, regularInterval) {
  if(!is.data.frame(x)) {
    stop("x must be of type data frame")
  }

  for(i in 1:nrow(x)) {
    for(j in 1:length(boundaries)) {
      if(as.numeric(x$day[i]) >= boundaries[j]+regularInterval & as.numeric(x$day[i]) <= boundaries[j+1]-regularInterval) {
        x$type[i] <- j
        break()
      }
      x$type[i] <- 0
    }
  }

  x %>% filter(type!=0)
}

#lista <- prepanel(otudata=oldotudata2,metadata=oldmetadata,taxonomydata=oldtaxonomydata)
#horizonplot(lista)
temptable <- prepanel(otudata=renotu,metadata=renmeta,subj=rensubj, thresh_prevalence=50, thresh_abundance = 0.25)
stop("DONE.")


# Deal with NA values - interpolate them? (thus to add interpolated data in between an interval just add an NA)
# What if an OTU starts with an NA? Ends with one?
# Improve system of OTU selection, and allow user to input bacteria names to analyze or # total to analyze


# rm variables before running again?
# allow generation of dot plots for time vs. abundance of a specific interesting bacteria? (By selecting a row)  Tool to make it interactive and to click on elements?
# make a standardized OTU table, and a seperate one for taxonomy (use inner-Join to find stuff)
